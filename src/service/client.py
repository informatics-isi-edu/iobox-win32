#!/usr/bin/env python
# 
# Copyright 2014 University of Southern California
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
Raw network client for HTTP(S) communication with ERMREST service.
"""

import os
import subprocess
import json
import base64
import urlparse
from httplib import HTTPConnection, HTTPSConnection, HTTPException, OK, CREATED, ACCEPTED, NO_CONTENT, CONFLICT, NOT_FOUND, FORBIDDEN, UNAUTHORIZED, BAD_REQUEST, INTERNAL_SERVER_ERROR, SERVICE_UNAVAILABLE, GATEWAY_TIMEOUT, BadStatusLine, CannotSendRequest
from datetime import datetime, timedelta
import sys
import traceback
import time
import shutil
import serviceconfig
import smtplib
from email.mime.text import MIMEText
import urllib
import hashlib

mail_footer = 'Do not reply to this message.  This is an automated message generated by the system, which does not receive email messages.'

class ErmrestHTTPException(Exception):
    def __init__(self, value, status):
        super(ErmrestHTTPException, self).__init__(value)
        self.value = value
        self.status = status
        
    def __str__(self):
        message = "%s." % self.value
        return message

class ErmrestException(Exception):
    def __init__(self, value, cause=None):
        super(ErmrestException, self).__init__(value)
        self.value = value
        self.cause = cause
        
    def __str__(self):
        message = "%s." % self.value
        if self.cause:
            message += " Caused by: %s." % self.cause
        return message

class MalformedURL(ErmrestException):
    """MalformedURL indicates a malformed URL.
    """
    def __init__(self, cause=None):
        super(MalformedURL, self).__init__("URL was malformed", cause)

class UnresolvedAddress(ErmrestException):
    """UnresolvedAddress indicates a failure to resolve the network address of
    the Ermrest service.
    
    This error is raised when a low-level socket.gaierror is caught.
    """
    def __init__(self, cause=None):
        super(UnresolvedAddress, self).__init__("Could not resolve address of host", cause)

class NetworkError(ErmrestException):
    """NetworkError wraps a socket.error exception.
    
    This error is raised when a low-level socket.error is caught.
    """
    def __init__(self, cause=None):
        super(NetworkError, self).__init__("Network I/O failure", cause)

class ProtocolError(ErmrestException):
    """ProtocolError indicates a protocol-level failure.
    
    In other words, you may have tried to add a tag for which no tagdef exists.
    """
    def __init__(self, message='Network protocol failure', errorno=-1, response=None, cause=None):
        super(ProtocolError, self).__init__("Ermrest protocol failure", cause)
        self._errorno = errorno
        self._response = response
        
    def __str__(self):
        message = "%s." % self.value
        if self._errorno >= 0:
            message += " HTTP ERROR %d: %s" % (self._errorno, self._response)
        return message
    
class NotFoundError(ErmrestException):
    """Raised for HTTP NOT_FOUND (i.e., ERROR 404) responses."""
    pass


class ErmrestClient (object):
    """Network client for ERMREST.
    """
    ## Derived from the ermrest iobox service client

    def __init__(self, **kwargs):
        self.baseuri = kwargs.get("baseuri")
        o = urlparse.urlparse(self.baseuri)
        self.scheme = o[0]
        host_port = o[1].split(":")
        self.host = host_port[0]
        self.path = o.path
        self.port = None
        if len(host_port) > 1:
            self.port = host_port[1]
        self.use_goauth = kwargs.get("use_goauth")
        self.username = kwargs.get("username")
        self.password = kwargs.get("password")
        self.mail_server = kwargs.get("mail_server")
        self.mail_sender = kwargs.get("mail_sender")
        self.mail_receiver = kwargs.get("mail_receiver")
        self.hatrac = kwargs.get("hatrac")
        self.namespace = urllib.quote(kwargs.get("namespace"), safe='')
        self.cookie = kwargs.get("cookie")
        self.chunk_size = kwargs.get("chunk_size")
        self.header = None
        self.webconn = None

    def send_request(self, method, url, body='', headers={}, sendData=False):
        try:
            if self.header:
                headers.update(self.header)
            if sendData == False:
                self.webconn.request(method, url, body, headers)
            else:
                
                """ For file upload send the request step by step """
                self.webconn.putrequest(method, url)
                for key,value in headers.iteritems():
                    self.webconn.putheader(key,value)
                self.webconn.endheaders()
                self.webconn.send(body)
            try:
                resp = self.webconn.getresponse()
            except BadStatusLine, CannotSendRequest:
                """ Resend the request """
                self.close()
                self.connect()
                self.sendMail('WARNING IOBox: HTTP BadStatusLine/CannotSendRequest exception', 'The HTTPSConnection has been restarted.\n')
                if sendData == False:
                    self.webconn.request(method, url, body, headers)
                else:
                     self.webconn.putrequest(method, url)
                     for key,value in headers.iteritems():
                         self.webconn.putheader(key,value)
                     self.webconn.endheaders()
                     self.webconn.send(body)
                resp = self.webconn.getresponse()
            if resp.status in [INTERNAL_SERVER_ERROR, SERVICE_UNAVAILABLE, GATEWAY_TIMEOUT]:
                """ Resend the request """
                self.close()
                self.connect()
                self.sendMail('WARNING IOBox: HTTP exception: %d' % resp.status, 'The HTTPSConnection has been restarted\n')
                if sendData == False:
                    self.webconn.request(method, url, body, headers)
                else:
                     self.webconn.putrequest(method, url)
                     for key,value in headers.iteritems():
                         self.webconn.putheader(key,value)
                     self.webconn.endheaders()
                     self.webconn.send(body)
                resp = self.webconn.getresponse()
            if resp.status not in [OK, CREATED, ACCEPTED, NO_CONTENT]:
                serviceconfig.logger.error('Error response: method="%s", url="%s", status=%i, error: %s' % (method, url, resp.status, resp.read()))
                raise ErmrestHTTPException("Error response (%i) received: %s" % (resp.status, resp.read()), resp.status)
            return resp
        except ErmrestHTTPException:
            raise
        except:
            et, ev, tb = sys.exc_info()
            serviceconfig.logger.error('got HTTP exception: method="%s", url="%s", error="%s"' % (method, url, str(ev)))
            serviceconfig.logger.error('%s' % str(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE HTTP', 'Error generated during the HTTP request: method="%s", url="%s", error="%s"' % (method, url, str(ev)))
            raise

    def connect(self):
        if self.scheme == 'https':
            self.webconn = HTTPSConnection(host=self.host, port=self.port)
        elif self.scheme == 'http':
            self.webconn = HTTPConnection(host=self.host, port=self.port)
        else:
            raise ValueError('Scheme %s is not supported.' % self.scheme)

        if self.use_goauth:
            self.header = {'Cookie': self.cookie}
            """
            auth = base64.encodestring('%s:%s' % (self.username, self.password)).replace('\n', '')
            headers = dict(Authorization='Basic %s' % auth)
            resp = self.send_request('GET', '/service/nexus/goauth/token?grant_type=client_credentials', '', headers)
            goauth = json.loads(resp.read())
            self.access_token = goauth['access_token']
            self.header = dict(Authorization='Globus-Goauthtoken %s' % self.access_token)
            """
        else:
            headers = {}
            headers["Content-Type"] = "application/x-www-form-urlencoded"
            resp = self.send_request("POST", "/ermrest/authn/session", "username=%s&password=%s" % (self.username, self.password), headers)
            self.header = dict(Cookie=resp.getheader("set-cookie"))
            resp.read()
        
    def add_subjects(self, observer, fileobj, st_size, action):
        """Registers a file in ermrest.
        
        Keyword arguments:
        
        fileobj -- the attributes of the register file 
        
        """
        
        ret = (None, None, None)
        body = []
        slide_id = fileobj['slide_id']
        sha256sum = fileobj['sha256sum']
        filename = fileobj['filename']
        file_from = fileobj['file_from']
        obj = self.getScanAttributes(filename, slide_id, sha256sum, st_size)
        body.append(obj)
        hatrac_transfer = True
        if action != 'transfer':
            url = '%s/entity/Scan' % self.path
            headers = {'Content-Type': 'application/json'}
            hatrac_transfer = False
            try:
                resp = self.send_request('POST', url, json.dumps(body), headers)
                resp.read()
                hatrac_transfer = True
                self.sendMail('SUCCEEDED ERMREST', 'Registered:\n%s' % json.dumps(body, indent=4))
            except ErmrestHTTPException, e:
                if action == 'recover' and e.status == CONFLICT:
                    hatrac_transfer = True
                elif e.status == CONFLICT:
                    self.sendMail('FAILURE ERMREST', 'Error(CONFLICT) generated during the POST request:\n%s' % str(e))
                    return (None, None, 'rejected')
                else:
                    self.sendMail('FAILURE ERMREST', 'Error generated during the POST request:\n%s' % str(e))
                    return (None, None, 'retry')
            except:
                et, ev, tb = sys.exc_info()
                self.sendMail('FAILURE ERMREST', 'Exception generated during the registering with the POST request:\n%s\n%s' % (str(ev), ''.join(traceback.format_exception(et, ev, tb))))
                return (None, None, 'rejected')
        
        if hatrac_transfer == True:
            try:
                job_id, status = self.transfer(file_from, slide_id, sha256sum)
                ret = (job_id, status, 'transfer')
            except:
                et, ev, tb = sys.exc_info()
                self.sendMail('FAILURE HATRAC', 'Exception generated during the hatrac transfer for the file "%s":\n%s\n%s' % (file_from, str(ev), ''.join(traceback.format_exception(et, ev, tb))))
                return (None, None, 'transfer')
        return ret
                    
    def getScanAttributes(self, filename, slide_id, sha256sum, st_size):
        obj = {}
        obj['ID'] = sha256sum
        obj['Slide ID'] = slide_id
        obj['Original Filename'] = filename
        obj['Filename'] = '%s.czi' % sha256sum
        obj['File Size'] = st_size
        return obj
    
    def close(self):
        """Closes the connection to the Ermrest service.
        
        The underlying python documentation is not very helpful but it would
        appear that the HTTP[S]Connection.close() could raise a socket.error.
        Thus, this method potentially raises a 'NetworkError'.
        """
        assert self.webconn
        try:
            self.webconn.close()
        except socket.error as e:
            raise NetworkError(e)
        finally:
            self.webconn = None

    def transfer(self, filePath, namespace_path, sha256sum):
        """Generate in hatrac the namespace_path namespace"""
        try:
            if self.retrieveNamespace(urllib.quote(namespace_path, safe='')) == None:
                self.createNamespace(urllib.quote(namespace_path, safe=''))
            """Upload the file in hatrac"""
            job_id, status = self.uploadFile('%s/%s' % (self.namespace, urllib.quote(namespace_path, safe='')), urllib.quote(sha256sum, safe=''), filePath)
            return (job_id, status)
        except:
            et, ev, tb = sys.exc_info()
            serviceconfig.logger.error('Can not transfer file "%s" in namespace "%s". Error: "%s"' % (filePath, namespace_path, str(ev)))
            raise
        
        
    def sendMail(self, subject, text):
        if self.mail_server and self.mail_sender and self.mail_receiver:
            try:
                msg = MIMEText('%s\n\n%s' % (text, mail_footer), 'plain')
                msg['Subject'] = subject
                msg['From'] = self.mail_sender
                msg['To'] = self.mail_receiver
                s = smtplib.SMTP(self.mail_server)
                s.sendmail(self.mail_sender, self.mail_receiver.split(','), msg.as_string())
                s.quit()
                serviceconfig.logger.debug('Sent email notification')
            except:
                et, ev, tb = sys.exc_info()
                serviceconfig.logger.error('got exception "%s"' % str(ev))
                serviceconfig.logger.error('%s' % str(traceback.format_exception(et, ev, tb)))

    def createNamespace(self, namespace_path):
        """
        Create a namespace for the namespace_path.
        """
        try:
            url = '%s/%s/%s' % (self.hatrac, self.namespace, namespace_path)
            headers = {'Content-Type': 'application/x-hatrac-namespace', 'Accept': 'application/json'}
            resp = self.send_request('PUT', url, headers=headers)
            res = resp.read()
        except:
            et, ev, tb = sys.exc_info()
            serviceconfig.logger.error('Can not create namespace "%s/%s". Error: "%s"' % (self.namespace, namespace_path, str(ev)))
            raise
            
    def retrieveNamespace(self, namespace_path):
        """
        Retrieve the namespace.
        """
        try:
            url = '%s/%s/%s' % (self.hatrac, self.namespace, namespace_path)
            headers = {'Content-Type': 'application/json', 'Accept': 'application/json'}
            resp = self.send_request('GET', url, '', headers)
            namespaces = json.loads(resp.read())
            return namespaces
        except ErmrestHTTPException, e:
            if e.status == NOT_FOUND:
                return None
            else:
                serviceconfig.logger.error('ErmrestHTTPException: Can not retrieve namespace "%s/%s". Error: "%s"' % (self.namespace, namespace_path, str(e)))
                raise
        except:
            et, ev, tb = sys.exc_info()
            serviceconfig.logger.error('Exception: Can not retrieve namespace "%s/%s". Error: "%s"' % (self.namespace, namespace_path, str(ev)))
            raise

    def uploadFile(self, namespace_path, object_name, filePath):
        """
            Upload a file
        """
        try:
            job_id = self.createUploadJob(namespace_path, object_name, filePath)
            self.chunksUpload(namespace_path, object_name, filePath, job_id)
            self.chunksUploadFinalization(namespace_path, object_name, job_id)
            return (job_id, 'SUCCEEDED')
        except:
            et, ev, tb = sys.exc_info()
            serviceconfig.logger.error('Can not upload file "%s" in namespace "%s/%s". Error: "%s"' % (filePath, namespace_path, object_name, str(ev)))
            raise
                
    def createUploadJob(self, namespace_path, object_name, filePath):
        """
        Create a job for uploading a file
        """
        try:
            hash_value = self.md5sum(filePath)
            file_size = os.path.getsize(filePath)
            url = '%s/%s/%s;upload' % (self.hatrac, namespace_path, object_name)
            headers = {'Content-Type': 'application/json'}
            obj = {"chunk_bytes": self.chunk_size,
                   "total_bytes": file_size,
                   "content_md5": hash_value,
                   "content_type": "application/octet-stream"}
            resp = self.send_request('POST', url, body=json.dumps(obj), headers=headers)
            res = resp.read()
            job_id = res.split('/')[-1][:-1]
            return job_id
        except:
            et, ev, tb = sys.exc_info()
            serviceconfig.logger.error('Can not create job for uploading file "%s" in namespace "%s/%s". Error: "%s"' % (filePath, namespace_path, object_name, str(ev)))
            raise

    def chunksUpload(self, namespace_path, object_name, filePath, job_id):
        """
        Upload a file through chunks
        """
        try:
            file_size = os.path.getsize(filePath)
            chunk_no = file_size / self.chunk_size
            last_chunk_size = file_size % self.chunk_size
            f = open(filePath, "rb")
            for index in range(chunk_no):
                position = index
                body = f.read(self.chunk_size)
                url = '%s/%s/%s;upload/%s/%d' % (self.hatrac, namespace_path, object_name, job_id, position)
                headers = {'Content-Type': 'application/octet-stream', 'Content-Length': self.chunk_size}
                resp = self.send_request('PUT', url, body=body, headers=headers, sendData=True)
                res = resp.read()
            if last_chunk_size > 0:
                position = chunk_no
                body = f.read(self.chunk_size)
                url = '%s/%s/%s;upload/%s/%d' % (self.hatrac, namespace_path, object_name, job_id, position)
                headers = {'Content-Type': 'application/octet-stream', 'Content-Length': last_chunk_size}
                resp = self.send_request('PUT', url, body=body, headers=headers, sendData=True)
                res = resp.read()
            f.close()
        except:
            et, ev, tb = sys.exc_info()
            serviceconfig.logger.error('Can not upload chunk for file "%s" in namespace "%s/%s" and job_id "%s". Error: "%s"' % (filePath, namespace_path, object_name, job_id, str(ev)))
            try:
                f.close()
                self.cancelJob(namespace_path, object_name, job_id)
            except:
                pass
            raise
            

    def chunksUploadFinalization(self, namespace_path, object_name, job_id):
        """
        Finalize the chunks upload 
        """
        try:
            url = '%s/%s/%s;upload/%s' % (self.hatrac, namespace_path, object_name, job_id)
            headers = {}
            resp = self.send_request('POST', url, headers=headers)
            res = resp.read()
        except:
            et, ev, tb = sys.exc_info()
            serviceconfig.logger.error('Can not finalize job "%s/%s/%s". Error: "%s"' % (namespace_path, object_name, job_id, str(ev)))
            raise
            
    def cancelJob(self, namespace_path, object_name, job_id):
        """
        Cancel a job
        """
        try:
            url = '%s/%s/%s;upload/%s' % (self.path, namespace_path, urllib.quote(object_name, safe=''), job_id)
            headers = {}
            resp = self.send_request('DELETE', url, headers=headers)
            res = resp.read()
        except:
            et, ev, tb = sys.exc_info()
            serviceconfig.logger.error('Can not cancel job "%s/%s/%s". Error: "%s"' % (namespace_path, object_name, job_id, str(ev)))
            raise
            
            
    def md5sum(self, fpath):
        """
        Return base64 digest string like md5 utility would compute.
        """
        h = hashlib.md5()
        try:
            f = open(fpath, 'rb')
            try:
                b = f.read(self.chunk_size)
                while b:
                    h.update(b)
                    b = f.read(self.chunk_size)
                return base64.b64encode(h.digest())
            finally:
                f.close()
        except:
            return None

